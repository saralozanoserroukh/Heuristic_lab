set DEPARTURES;
set ARRIVALS;
set STUDENTS;

param cost {d in DEPARTURES, a in ARRIVALS};
param demand {d in DEPARTURES};
param cost_bus;
param cost_km;
param bus_capacity;
param siblings{s1 in STUDENTS, S2 in students}
param possible_stops {s in STUDENTS, d in DEPARTURES};

var bin_x {d in DEPARTURES, a in ARRIVALS} binary;
var flow_x {d in DEPARTURES, a in ARRIVALS} integer, >=0;
var assigned_stops {s in STUDENTS, d in DEPARTURES};

minimize budget:
  (sum {d in DEPARTURES, a in ARRIVALS} cost_km*cost[d,a]*bin_x[d,a]) + (sum {a in ARRIVALS} cost_bus*bin_x['PARKING',a]);
	
s.t. same_leave_enters: sum{d in DEPARTURES, a in ARRIVALS} bin_x['PARKING',a] - bin_x[d,'SCHOOL'] = 0;
s.t. fulfill_demand {x in DEPARTURES}: (sum{d in DEPARTURES} flow_x[d,x]) - (sum{a in ARRIVALS} flow_x[x,a]) = demand[x];
s.t. correct_flow {d in DEPARTURES, a in ARRIVALS}: bus_capacity*bin_x[d,a]-flow_x[d,a] >= 0;
s.t. correct_rows {d in DEPARTURES: d <> 'PARKING' and d <> 'SCHOOL'}: sum{a in ARRIVALS} bin_x[d,a] = 1;
s.t. correct_cols {a in ARRIVALS: a <> 'PARKING' and a <> 'SCHOOL'}: sum{d in DEPARTURES} bin_x[d,a] = 1;
s.t. correct_stop {s in STUDENTS, d in DEPARTURES} possible_stops[s,d] - assigned_stops[s,d] >= 0;
s.t. check_sibling {d in DEPARTURES, s1 in STUDENTS, s2 in STUDENTS} assigned_stop[s1,d]*siblings[s1,s2]-assigned_stop[s2,d]*siblings[s1,s2] = 0;

end;
